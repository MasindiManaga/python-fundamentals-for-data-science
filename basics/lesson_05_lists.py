"""
LESSON 5 — Lists (Expanded, System-Level Understanding)

1. What is a list?
A list is:
- An ordered collection of reference to objects stored under one name that can
grow, shrink, and change.

I can think of a list as:
A row of labeled boxes, each box pointing to something.

- You can create an empty list using either square brackets or the list() constructor.
- You can add elements using append(), insert(), or concatenate().
- You can remove elements using remove().

!!! A list does not store values directly, it stores references just like variables.

2. Why do lists exist?
Without lists:
- You repeat variables (score1, score2, score3)
- You can't scale
- You can't loop meaningfully
- You can't store unknown amounts of data

Lists permit:
- Unknown-length data
- Repetition with structure
- State accumulation
- History tracking

Real-world examples:
- Transaction history
- Elevator stops
- Menu options
- Student marks
- Game inventory

3. Creating lists:
lists can represent:
- Data you already know
- Data collected over time
- Data generated by logic
- Data derived from other data

Key idea:
A list can start empty and become meaningful later.

4. Indexing - accessing position
Lists are indexed,meaning:
- Every element has a position
- Position starts at 0
- Position ends at -1
- Order matters

Why index O?
- Efficiency
- Memory layout
- Historical reasons

!!! Index = "where", not "what"

5. Negative indexing
Python allows you to count from the end.

This teaches:
- Relative positioning
- End-state awareness
- Flexibility in access

System insight:
You often care about "latest", "last action", or "most recent."

Negative indexing supports that naturally.

6. Slicing - extracting views of data
Slicing:
- Creates new lists
- Preserves order
- Does not affect the original

This is critical for:
- Undo features
- History snapshots
- Safe data processing

Mental model:
"Give me a portion, not the whole"

7. Mutability - lists can change
Lists are mutable:
- You can add
- You can remove
- You cna replace elements

This introduces:
- Side effects
- Shared references
- Coupling risks

System-level thinking:
If two variables point to the same list, a change affects both.

8. Core list actions (the purpose of their existence)
Without naming methods yet, conceptually you can:
- Add new data (growth)
- Remove old data (cleanup)
- Reorder data (priority)
- Inspect size (capacity)
- Iterate through contents (processing)

These actions map directly to real systems:
- Queues
- Logs
- Histories
- Buffers

9. Iteration + lists (power combo)
Lists shine when combined with loops.

This permits:
- Repeating logic over unknown data
- Applying rules consistently
- Automating decisions

Mental shift:
"I don't act on one thing - I act on all things of this type."

This is how programs scale.

10. Lists as state containers
Lists often represent state over time.

Examples:
- Elevator floor visited
- Menu actions chosen
- Scores over rounds
- Errors encountered

Key insight:
A list remembers what the system has experienced.

That's memory.

11. Coupling and lists:
Lists often create hidden coupling:
- A function changes a list it didn't create.
- Another part of the program relies on its old state.

Good practice:
- Be clear who owns the list.
- Decide who is allowed to modify it.
- Document expectations

This matters in real systems.

12. Lists vs single variables (design choice)
Aks:
- Do I need history?
- Do I need scale?
- Do I need iteration?
- Do I need order?

If yes → list.
If no → single variable.

!!!Design first, code second.
~Lists are about organization of experience~


"""
#List of numbers
nums = [25, 12, 36, 95, 14] #Assign multiple numbers using square brackets
print(nums) #prints the list
print(nums[0]) #prints the first number
print(nums[4]) #prints the last number
print(nums[-1]) #prints the last number
print(nums[2:])#prints number in between from 36-14 -slicing method

#List of names
names = ['Masindi', 'karin', 'john']
print(names)

#List of different types of data
values = [9.5, 'Masindi', 25]

#List of list
mil = [nums, names]
print(mil)

#check for length
if len(mil) == 0:
    print("The list is empty.")

#Operations on list
nums.append(45) #adds number at the end
print(nums)

nums.insert(2,77)
print(nums) #inserts number at the index stated initially

nums.remove(14)
print(nums) #deletes the number you stated

nums.pop(1) #deletes the number at index 1
print(nums)

nums.pop()
print(nums) #last element is removed

print(min(nums))
print(max(nums))
print(sum(nums))

"""
Push - adds elements
Pop - removes elements
"""

#delete multiple values
del nums[2:]
print(nums)

#add multiple values
nums.extend([29, 12, 14, 36])
print(nums)

nums.sort()
print(nums)


#Project 1: Collection  Builder
"""Show that a list can start empty and grow over time."""
numbers = [] #creates an empty list
present_val = 4 #start the counter value at 4

if len(numbers) == 0:
    print("The list is empty.")

while len(numbers) < 5:
    numbers.append(present_val)
    present_val +=2

print(numbers)

#Project 2: History Tracker
"""Demonstrate lists as memory over time"""
actions = []

while True:
    action = input("What do you want to do (login, view, logout): ").lower().strip()
    actions.append(action)

    if action == "login":
        print("Logged in.")
    elif action == "view":
        print(f"These are the actions: {actions}")
    elif action == "logout":
        print("Logged out.")
        break
    else:
        print("invalid action")
        continue

#Project3: List inspection (Read-only)
"""indexing, negative indexing, slicing without mutation risk."""
list_inst = []
number = 1

for i in range(10):
    list_inst.append(number)
    number += 1
    print(list_inst)

print("\n")
print(list_inst[0])
print(list_inst[-1])
print(list_inst[2:])
print(list_inst[:-2])

