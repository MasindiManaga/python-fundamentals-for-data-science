#----------------------------------------
"""
LESSON 5 — Lists (Expanded, System-Level Understanding)

1. What is a list?
A list is:
- An ordered collection of reference to objects stored under one name that can
grow, shrink, and change.

I can think of a list as:
A row of labeled boxes, each box pointing to something.

!!! A list does not store values directly, it stores references just like variables.

2. Why do lists exist?
Without lists:
- You repeat variables (score1, score2, score3)
- You can't scale
- You can't loop meaningfully
- You can't store unknown amounts of data

Lists permit:
- Unknown-length data
- Repetition with structure
- State accumulation
- History tracking

Real-world examples:
- Transaction history
- Elevator stops
- Menu options
- Student marks
- Game inventory

3. Creating lists:
lists can represent:
- Data you already know
- Data collected over time
- Data generated by logic
- Data derived from other data

Key idea:
A list can start empty and become meaningful later.

4. Indexing - accessing position
Lists are indexed,meaning:
- Every element has a position
- Position starts at 0
- Position ends at -1
- Order matters

Why index O?
- Efficiency
- Memory layout
- Historical reasons

!!! Index = "where", not "what"

5. Negative indexing
Python allows you to count from the end.

This teaches:
- Relative positioning
- End-state awareness
- Flexibility in access

System insight:
You often care about "latest", "last action", or "most recent."

Negative indexing supports that naturally.

6. Slicing - extracting views of data
Slicing:
- Creates new lists
- Preserves order
- Does not affect the original

This is critical for:
- Undo features
- History snapshots
- Safe data processing

Mental model:
"Give me a portion, not the whole"

7. Mutability - lists can change
Lists are mutable:
- You can add
- You can remove
- You cna replace elements

This introduces:
- Side effects
- Shared references
- Coupling risks

System-level thinking:
If two variables point to the same list, a change affects both.

8. Core list actions (the purpose of their existence)
Without naming methods yet, conceptually you can:
- Add new data (growth)
- Remove old data (cleanup)
- Reorder data (priority)
- Inspect size (capacity)
- Iterate through contents (processing)

These actions map directly to real systems:
- Queues
- Logs
- Histories
- Buffers

9. Iteration + lists (power combo)
Lists shine when combined with loops.

This permits:
- Repeating logic over unknown data
- Applying rules consistently
- Automating decisions

Mental shift:
"I don't act on one thing - I act on all things of this type."

This is how programs scale.

10. Lists as state containers
Lists often represent state over time.

Examples:
- Elevator floor visited
- Menu actions chosen
- Scores over rounds
- Errors encountered

Key insight:
A list remembers what the system has experienced.

That's memory.

11. Coupling and lists:
Lists often create hidden coupling:
- A function changes a list it didn't create.
- Another part of the program relies on its old state.

Good practice:
- Be clear who owns the list.
- Decide who is allowed to modify it.
- Document expectations

This matters in real systems.

12. Lists vs single variables (design choice)
Aks:
- Do I need history?
- Do I need scale?
- Do I need iteration?
- Do I need order?

If yes → list.
If no → single variable.

!!!Design first, code second.
~Lists are about organization of experience~
"""
#-----------------------------------------
